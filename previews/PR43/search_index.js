var documenterSearchIndex = {"docs":
[{"location":"#ThreadsX.jl-1","page":"Home","title":"ThreadsX.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Modules = [ThreadsX]","category":"page"},{"location":"#ThreadsX.MergeSort","page":"Home","title":"ThreadsX.MergeSort","text":"ThreadsX.MergeSort\n\nParallel merge sort algorithm.\n\nExamples\n\nThreadsX.sort!(x; alg = MergeSort)\n\nis more or less equivalent to\n\nsort!(x; alg = ThreadsX.MergeSort)\n\nalthough ThreadsX.sort! may be faster for very large integer arrays as it also parallelize counting sort.\n\nThreadsX.MergeSort is a Base.Sort.Algorithm, just like Base.MergeSort.  It has a few properties for configuring the algorithm.\n\njulia> using ThreadsX\n\njulia> ThreadsX.MergeSort isa Base.Sort.Algorithm\ntrue\n\njulia> ThreadsX.MergeSort.smallsort === Base.Sort.DEFAULT_STABLE\ntrue\n\nThe properties can be \"set\" by calling the algorithm object itself.  A new algorithm object with new properties given by the keyword arguments is returned:\n\njulia> alg = ThreadsX.MergeSort(smallsort = QuickSort) :: Base.Sort.Algorithm;\n\njulia> alg.smallsort == QuickSort\ntrue\n\njulia> alg2 = alg(basesize = 64, smallsort = InsertionSort);\n\njulia> alg2.basesize\n64\n\njulia> alg2.smallsort === InsertionSort\ntrue\n\nProperties\n\nsmallsort :: Base.Sort.Algorithm: Default to Base.Sort.DEFAULT_STABLE.\nsmallsize :: Union{Nothing,Integer}: Size of array under which smallsort algorithm is used.  nothing (default) means to use basesize.\nbasesize :: Union{Nothing,Integer}.  Base case size of parallel merge. nothing (default) means to choose the default size.\n\n\n\n\n\n\n\n","category":"constant"}]
}
